# CURSORRULES.md

## All updates to the codebase should include additions to the .cursorupdate file in the root of the project that clearly explain the changes to each file.

## Always build the project after making changes.
- Run `npm run build` to build the extension
- Git commits to main branch will automatically trigger Vercel deployments
- No need to run Vercel deploy commands manually

## Extension Overview
The Pulse Scientific Chrome Extension provides an interactive overlay on research articles, allowing verified experts to comment via email replies. It leverages Supabase for data storage, SendGrid for inbound/outbound email, and a React + Tailwind UI for the injected overlay.

## Tech Stack
- **Chrome Extension**: Manifest v3, service worker, content scripts
- **React**: UI rendering via Vite + React (in `src/`)
- **Tailwind CSS**: Styling (utility classes)
- **Supabase**: Database for comments, email tokens, etc.
- **SendGrid**: Email sending and inbound parse webhook
- **Serverless**: Deployed on Verce

## Project Structure

The project file tree is maintained in this repository (pulsev3).
When adding or renaming files, update the file structure accordingly.

Example (abbreviated):
pulsev3
├── api
│   ├── inbound.ts
│   ├── webhook.ts
│   └── …
├── public
│   ├── manifest.json
│   ├── content.js
│   ├── background.js
│   ├── content.css
│   └── icons/…
├── src
│   ├── components/ui
│   ├── lib
│   ├── stories
│   └── …
├── supabase
│   ├── migrations
│   └── …
└── scripts
├── test-email.ts
└── …

## Core Architecture Rules

1. **Extension Injection**  
   - Only `content.js` modifies the DOM of a visited page.  
   - `content.css` styles the injected overlay.  
   - `background.js` acts as the extension's service worker, handling Google OAuth via `chrome.identity`.

2. **Serverless API**  
   - All inbound email webhooks and event tracking are routed through Vercel serverless functions in `/api/`.  
   - `api/inbound.ts`: Processes inbound emails, validates tokens, stores comments.  
   - `api/webhook.ts`: Handles SendGrid event callbacks (delivered, opened, etc.).

3. **Email Tokens**  
   - Each email request contains a single-use token embedded in `reply+<token>@domain`.  
   - The `email_tokens` table in Supabase ensures a token can be used only once and expires automatically.

4. **Supabase as Source of Truth**  
   - All comments and expert data live in Supabase.  
   - The extension fetches comments from Supabase on load and on updates.

5. **UI Architecture**  
   - Reusable UI primitives in `src/components/ui/`.  
   - The overlay uses React for rendering, and merges data from Supabase with local state (Google sign-in info).

## Implementation Guidelines

1. **Email Reply Flow**  
   - Use `sendInitialEmail()` from `src/lib/email.ts` to generate a token and send out requests for commentary.  
   - Inbound parse is processed by `api/inbound.ts`.  
   - Validates tokens against `email_tokens` table, inserts a new `comment` if all checks pass.

2. **Overlay UI**  
   - Minimal inline logic in `content.js`.  
   - Renders HTML elements from `content.js` plus React-based components from `src/components/ui/`.  
   - **Tailwind** classes for styling; no external CSS files beyond `content.css`.

3. **Sign-In & Authorization**  
   - `background.js` obtains Google OAuth token.  
   - The overlay re-checks token validity when needed.  
   - Supabase policies and RLS ensure that only relevant data is exposed.

4. **Comments Storage**  
   - `comments` table schema includes `article_id`, `expert_email`, `content`, timestamps, and optional metadata (e.g., `dkim`, `spf`, `correlation_id`).  
   - **Single Use**: The `email_tokens` record flips its `used` flag upon successful comment insertion.

5. **Error Handling**  
   - Return JSON errors from Vercel functions with clear status codes.  
   - In the extension's overlay, display user-friendly messages for network errors or token issues.

## Common Patterns

### 1. Sending an Email Request
```ts
// scripts/test-email.ts
async function sendTestEmail() {
  const testEmail = {
    expertName: "Test Expert",
    expertEmail: "expert@example.com",
    articleTitle: "Sample Article",
    articleId: "sample-123"
  };
  await sendInitialEmail(testEmail);
  console.log("Test email sent");
}

2. Inbound Email Processing

// api/inbound.ts
export default async function handler(req, res) {
  // 1. Validate POST method, parse multipart/form-data
  // 2. Extract token from reply+<token>@domain
  // 3. Look up token in Supabase; if valid, insert a new comment
  // 4. Mark token as used
  // 5. Return success JSON
}

3. Overlay DOM Injection

// public/content.js
function createOverlay() {
  // 1. Insert header & sidebars
  // 2. Load comments from Supabase
  // 3. Attach sign-in logic from background.js
  // 4. Provide toggles to hide/show sidebars
}
createOverlay();

4. Comments UI

// src/components/ui/comments/CommentsList.tsx
export function CommentsList({ articleId }: { articleId: string }) {
  const [comments, setComments] = useState<Comment[]>([]);

  useEffect(() => {
    fetchComments(articleId).then(setComments);
  }, [articleId]);

  return (
    <ul>
      {comments.map((c) => (
        <li key={c.id}>
          <strong>{c.expert_email}</strong>: {c.content}
        </li>
      ))}
    </ul>
  );
}

Note: Keep these guardrails in place when adding or modifying files. All new changes should respect:
	•	Single-use tokens for comment insertion
	•	Supabase as the authoritative data source
	•	React + Tailwind for the overlay
	•	Serverless approach for inbound/outbound email events

## Testing Email Flow

1. **Running the Test Email Script**
   ```bash
   # The easiest way to test email flow is:
   npm run test:email
   ```
   This will send a test email to sean.w.meehan@gmail.com using the script in `scripts/test-email.ts`.

2. **What the Test Script Does**
   - Uses `sendInitialEmail()` to send a test email
   - Creates a one-time token in Supabase
   - Embeds the token in the reply-to address
   - Links to a specific article in our database (IMPORTANT: must use valid article_id)
   - Returns the token ID for tracking

3. **Testing the Reply Flow**
   - Wait for the test email to arrive
   - Reply with a simple message (e.g., "test reply")
   - The system will:
     - Parse your reply
     - Strip quoted content
     - Store only your reply text as a comment

4. **Troubleshooting Test Emails**
   - If email not received: Check SendGrid API key in .env
   - If token error: Ensure expert email exists in experts table
   - If comment not showing up: Verify articleId exists in articles table
   - If parsing issues: Check api/inbound.ts logs

Note: The test script is in `scripts/test-email.ts`. DO NOT modify the expert email or article ID unless you've verified they exist in the respective Supabase tables first.

// comment